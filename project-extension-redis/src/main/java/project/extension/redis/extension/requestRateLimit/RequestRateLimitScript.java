package project.extension.redis.extension.requestRateLimit;

/**
 * 限制请求速率脚本
 *
 * @author LCTR
 * @date 2023-03-29
 */
public class RequestRateLimitScript {
    public static String getScriptText() {
        return "-- 传入的要操作的key:tokenKey\n"
                + "local tokenKey = KEYS[1]\n"
                + "-- 传入的要操作的key:timestampKey\n"
                + "local timestampKey = KEYS[2]\n"
                + "\n"
                + "-- 参数1：令牌桶的大小\n"
                + "local capacity = tonumber(ARGV[1])\n"
                + "-- 参数2：生成令牌的速度\n"
                + "local rate = tonumber(ARGV[2])\n"
                + "-- 参数3：当前时间的秒数\n"
                + "local nowTimestamp = tonumber(ARGV[3])\n"
                + "-- 参数4：请求令牌数\n"
                + "local requested = tonumber(ARGV[4])\n"
                + "\n"
                + "-- redis.log(redis.LOG_NOTICE,\"tokenKey:\" .. tokenKey)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"timestampKey:\" .. timestampKey)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"capacity:\" .. capacity)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"rate:\" .. rate)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"nowTimestamp:\" .. nowTimestamp)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"requested:\" .. requested)\n"
                + "\n"
                + "-- 计算令牌桶填充时间，令牌桶的大小/生成令牌的速度\n"
                + "local fillTime = capacity / rate\n"
                + "-- 失效时间向下取整，采用两倍填充时间保证失效时间充足\n"
                + "local expireTime = math.floor(fillTime * 2)\n"
                + "\n"
                + "-- 从redis获取上一次tokenKey的值，如果返回nil，则初始化令牌桶，结果转为数字\n"
                + "local lastToken = tonumber(redis.call(\"get\", tokenKey) or capacity)\n"
                + "-- 从redis获取上一次timestampKey的值，如果返回nil，则时间设置为0，结果转为数字\n"
                + "local lastTimestamp = tonumber(redis.call(\"get\", timestampKey) or 0)\n"
                + "-- 当前时间和最后一次获取的时间的差值：秒数取值范围是从0到expireTime 或者 当前时间值\n"
                + "local timeGaps = math.max(0, nowTimestamp - lastTimestamp)\n"
                + "\n"
                + "-- redis.log(redis.LOG_NOTICE,\"fillTime:\" .. fillTime)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"expireTime:\" .. expireTime)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"lastToken:\" .. lastToken)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"lastTimestamp:\" .. lastTimestamp)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"timeGaps:\" .. timeGaps)\n"
                + "\n"
                + "-- 同1秒内的timeGaps的值都是0，令牌桶的数不会增加，直到扣减完，超过1秒的都会填充令牌\n"
                + "local filledToken = math.min(capacity, lastToken + (timeGaps * rate))\n"
                + "-- 新拿到的令牌值默认是填充后的filledToken\n"
                + "local newToken = filledToken\n"
                + "-- 令牌数大于等于请求令牌数说明可以获取到令牌\n"
                + "local allowed = filledToken >= requested\n"
                + "\n"
                + "-- 如果可以拿到令牌，则令牌数扣减掉请求数，得到令牌值\n"
                + "if allowed\n"
                + "then\n"
                + "  newToken = filledToken - requested\n"
                + "end\n"
                + "\n"
                + "-- redis.log(redis.LOG_NOTICE,\"filledToken:\" .. filledToken)\n"
                + "-- redis.log(redis.LOG_NOTICE,\"allowed:\" .. tostring(allowed))\n"
                + "-- redis.log(redis.LOG_NOTICE,\"newToken:\" .. newToken)\n"
                + "\n"
                + "-- 通过redis设置tokenKey的值为newToken，失效时间为expireTime\n"
                + "redis.call(\"setex\", tokenKey, expireTime, newToken)\n"
                + "-- 通过redis设置timestampKey的值为nowTimestamp，失效时间为expireTime\n"
                + "redis.call(\"setex\", timestampKey, expireTime, nowTimestamp)\n"
                + "\n"
                + "-- 返回结果：是否拿到令牌\n"
                + "return allowed";
    }
}
